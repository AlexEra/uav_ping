#include <Arduino.h>
#include "config.h"


// #define TEST


void choose_channel(uint8_t ch);
void print_channels_values(void);
bool check_channel_value(uint8_t ch);
void warn_user(void);


uint16_t rssi_values[8]; // array for keeping channels values


void setup() {
    init_peripherals();
#ifdef TEST
    choose_channel(0);
    delay(SWITCH_DELAY);
#endif
}


void loop() {
    static uint8_t choosed_channel = 0;

#ifndef TEST
    choose_channel(choosed_channel);
    if (++choosed_channel >= 8) {
        choosed_channel = 0;
        print_channels_values(); // print all data after updating
    }

    if (check_channel_value(choosed_channel)) {
        warn_user();
    }
#else
    char symb = Serial.read();
    switch (symb) {
        case 'c':
            if (++choosed_channel >= 8) choosed_channel = 0;
            Serial.print("Channel: "); Serial.println(choosed_channel + 1);
            choose_channel(choosed_channel);
            while (Serial.available()) Serial.read();
            break;

        case '1':
        case '2':
        case '3':
        case '4':
        case '5':
        case '6':
        case '7':
        case '8':
            choosed_channel = (uint8_t)symb - 49;
            Serial.print("Channel: "); Serial.println(choosed_channel + 1);
            choose_channel(choosed_channel);
            while (Serial.available()) Serial.read();
            break;
    }
    Serial.println(analogRead(RSSI));
    delay(100);
#endif
}

/**
 * @brief Choosing channel with delay after switching
 * 
 * @param ch Channel to switch for
 */
void choose_channel(uint8_t ch) {
    switch (ch) {
        case 0:
            digitalWrite(CH_SEL_0, 0);
            digitalWrite(CH_SEL_1, 0);
            digitalWrite(CH_SEL_2, 0);
            break;

        case 1:
            digitalWrite(CH_SEL_0, 1);
            digitalWrite(CH_SEL_1, 0);
            digitalWrite(CH_SEL_2, 0);
            break;

        case 2:
            digitalWrite(CH_SEL_0, 0);
            digitalWrite(CH_SEL_1, 1);
            digitalWrite(CH_SEL_2, 0);
            break;

        case 3:
            digitalWrite(CH_SEL_0, 1);
            digitalWrite(CH_SEL_1, 1);
            digitalWrite(CH_SEL_2, 0);
            break;

        case 4:
            digitalWrite(CH_SEL_0, 0);
            digitalWrite(CH_SEL_1, 0);
            digitalWrite(CH_SEL_2, 1);
            break;

        case 5:
            digitalWrite(CH_SEL_0, 1);
            digitalWrite(CH_SEL_1, 0);
            digitalWrite(CH_SEL_2, 1);
            break;

        case 6:
            digitalWrite(CH_SEL_0, 0);
            digitalWrite(CH_SEL_1, 1);
            digitalWrite(CH_SEL_2, 1);
            break;

        case 7:
            digitalWrite(CH_SEL_0, 1);
            digitalWrite(CH_SEL_1, 1);
            digitalWrite(CH_SEL_2, 1);
            break;
    }
    delay(SWITCH_DELAY);
}

/**
 * @brief Printing via Serial RSSI channels data 
 */
void print_channels_values(void) {
    for (uint8_t i = 0; i < 8; i++) {
        Serial.print(rssi_values[i]);
        Serial.print('\t');
    }
    Serial.println();
}

/**
 * @brief Checking the channel's analog value
 * 
 * @param ch Channel number for value checking
 * 
 * @return True if value is more than thershold value defined in config.h, false otherwise
 */
bool check_channel_value(uint8_t ch) {
    rssi_values[ch] = analogRead(RSSI);
    if (rssi_values[ch] > RSSI_THRESHOLD) return true;
    return false;
}

/**
 * @brief Warning the user that was found corresponding signal
 */
void warn_user(void) {
    uint8_t led_state = 1;

    for (uint8_t i = 0; i < 7; i++) {
        digitalWrite(LED, led_state);
        if (led_state) {
            led_state = 0;
            // analogWrite(BEEPER, BEEPER_DUTY);
        } else {
            led_state = 1;
            analogWrite(BEEPER, 0);
        }
        delay(200); 
    }
    analogWrite(BEEPER, 0);
    digitalWrite(LED, 0);
}
